# <font color = '#FF000'>**11.01**</font>

### 一、Redis数据库的介绍：

1.**NOSQL**: 泛指<font color = '#00FF00'>**非关系型**</font>数据库, 对**RDBMS**<font color = '#00FF00'>**关系型**</font>数据库的一个补充;数据的组织方式表较灵活，大部分是以【键值对】的形式来储存和管理；

例：键名/值  ：redis : name  "Tom" age  23    mongdb: name:"Tom"

2.redis:远程服务字典，是开源免费(开放源代码，配置文件中参数可以根据实际情况作出修改)，

​                                            基于内存(整个数据库全部加载到内存，数据直接存放在内存里)，

​                                                跨平台(可以在多个系统中使用)的非关系型数据库；

```
事务的执行过程可以分为三个阶段：开始事务、命令入队、执行事务。在开始事务后，所有的命令不会立即执行，而是被放入一个队列中。当执行事务时，Redis 会按照命令入队的顺序依次执行队列中的命令。如果在执行过程中出现错误，整个事务会被回滚，所有的命令都不会生效。

通过 Redis 事务，可以将多个操作作为一个原子操作进行处理，保证了数据的一致性。此外，Redis 事务还支持对命令进行监视和乐观锁机制，以实现并发控制。

需要注意的是，Redis 事务并不是严格意义上的 ACID 事务，它没有提供隔离性和持久性。因此，在使用 Redis 事务时，需要注意其适用的场景和限制。

ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）,一致性（consistency）,隔离性（isolation，又称独立性）,持久性（durability）。
```

```
为什么 Redis 需要把所有数据放到内存中?
  快速读写操作
  高吞吐量
　大规模集群
  数据持久性控制
```

3.redis: 

```
        1)数据库直接在内存;
        2)支持的数据类型，以及数据类型的操作命令较多;
        3)数据的读写处理速度是较快的;
        4)持久化功能:利用生成的持久文件可以避免因异常操作引发数据丢失的问题，实现数据的恢复(备份与恢复);
        redis数据库可以对键值对key-value设置有效活跃时间，一旦过了时间，就会被系统删掉;
        支持事务的操作:事务指的是在当前数据库中一次性做的并行处理的操作,这些操作具有原子性;对数据要么执行，要么失败/取消;
```

### 二、Redis和MySQL对比:

```
        1)类型: mysql:关系型数据库;
               redis:非关系型数据库;
        2)存储位置:mysql:数据存储在本地磁盘;
                 redis:数据存储在内存;
        3)侧重点:mysql:偏向于存数据;
                redis:偏向于读取数据;
```

### 三、Redis数据库的增删改查的操作:

<font color = '#FF0000'>1.redis自带16个数据库：库下表：0-15，默认在0号库；</font> :record_button:切换数据库：select  库下表

:game_die:

```
2.set        键名 值    添加键值对数据       前提:该键在库中不存在
```

```
3.set        键名 新值  修改键的数据         前提:该键在库中存在
```

```
4.get        键名                          获取该键中的值
```

```
5.del        键名                          删除键值对数据
```

:dancer:

### 四、Redis数据库中关于Key建设的操作命令：Key命令   :kaaba:

```
1.exists     键名          判断键名是否存在;
```

```
2.type       键名          查看该键的数据类型;
```

```
3.keys       字符模板       查看和该字符模板相关的键名  * 任意所有;
           
             例：keys s*   显示所有是以s开头      keys *s* 包含s的键名;
```

```
4.keys        *            显示所有的键名;
```

```
5.randomkey                随机返回一个存在的键;
```

```
6.rename      旧键名 新键名  对键名进行重命名;
```

```
7.dbsize                   统计当前库中键的个数;
```

```
8.expire      键名 时间(s)  设置该键的有效活动时间;
```

```
9.ttl         键名          查看一个键的活动时间;
```

```
10.move       键名 库编号    移动键到指定库;
```

```
11.flushdb                 删除当前库中的所有键;
```

```
12.flushall                删除所有库中的所有键;
```

```
13.set 键名 值 ex 时间(s)    在设定键值对的同时进行失效时间的设定;
```

```
14.exit                    退出,断开redis数据库的连接;
```

```
15.info                    查看redis版本信息描述;
```

### 五、Redis数据类型以及相关的命令操作(**五大数据类型**)    :mailbox_closed:

#### <font color = '#FF0000'>1.字符串类型   :sailboat:       string                      是redis数据库基本的数据类型</font>     :signal_strength:

```
        1)mset     键名1 值1 键名2 值2     批量向库中插入多个键值对数据;
```

```
        2)mget     键名1 键名2            获取多个键的值;
```

```
        3)getset   键名 新值              显示键中原始的值并把新值赋值给键;
```

```
        4)setnx    键名 值                添加新的键值对,如果键存在,什么都不会做;
```

```
        5)msetnx   键名1 值1 键名2 值2     添加多个键值对,如果键存在,什么都不会做;
```

```
        6)setex    键名 时间(s) 新值       修改键的值,并关联有效活动时间;
```

```
        7)incr     键名                   对键中的值进行加1的操作;
```

```
        8)incrby   键值 数值               指定数值的增加操作;
```

```
        9)decr     键名                   对键中的值进行减1的操作;
```

```
       10)decrby   键名 数值               指定数值的减法操作;
```

```
       11)append   键名 新值               将新的值拼接在原始键中值的后面;
```

```
       12)substr   键名 开始位置的下标 结束位置的下标      截取字符串的操作
```

```
       13)getrange 键名 开始位置的下标 结束位置的下标      截取字符串的操作
```

```
       14)setrange 键名 开始位置的下标 新值   从指定位置拿上新的值替换键中的旧值,得到一个新的字符串;
```

```
       15)strlen   键名                   统计该键中的存储的字符串长度(字符总个数)
```

#### <font color = '#FF0000'>2.列表/链表类型            list               用来存储多个字符串类型的值，键：值；1--->多</font>  :lantern:

```
        1)lpush    键名 值1 值2 值3        从列表的**头部**插入数据             
```

```
        2)rpush    键名 值1 值2 值3        从列表的**尾部**插入数据
```

```
        3)lrange   键名 开始下标 结束下标    查看列表范围内的数据信息
```

```
        4)llen     键名                   统计列表键的长度(存储的值的总个数)
```

```
        5)lindex   键名 下标               查看下标位置上的值
```

```
        6)lset     键名 下标 新值           修改列表键中对应位置的值
```

```
        7)lrem     键名 数量 值             从列表中删除指定数量的值
```

```
        8)lpop     键名                    显示并删除列表中的首个值
```

```
        9)rpop     键名                    显示并删除列表中的尾部值
```

```
       10)linsert  键名 before 值 新值      在指定元素值的前面插入新的数据值
```

```
       11)linsert  键名 after  值 新值      在指定元素值的后面插入新的数据值
```

```
       12)ltrim    键名 开始位置的下标 结束位置的下标    对列表中的数据进行截取(键中只保留截取后剩下的数据)
```

#### <font color = '#FF0000'>**3.set集合：存储字符串类型的数据：唯一，无序** </font>    :see_no_evil:

```
        1)sadd     键名 值1 值2 值3         创建/插入集合中的值
```

```
        2)smembers 键名                    查看键中的所有的值
```

```
        3)srem     键名 值                 删除键中的数据
```

```
        4)spop     键名                    返回并删除键中的一个值
```

```
        5)smove    键名1 键名2 元素值       将键名1中的值移动到键名2
```

```
        6)scard    键名 值                 统计集合键中值的总个数
```

```
        7)sismember 键名 值                检测到该值中是否在集合键中
```

```
        8)sinter   键名1 键名2             求**交集**:把共有的数据显示出来
```

```
        9)sinterstore 新的键名 键名1 键名2  求**交集**并保存在新的键中
```

```
       10)sunion   键名1 键名2             求**并集**:集合键之间做融合
```

```
       11)sunionstore 新的键名 键名1 键名2  求**并集**并保存在新的键
```

```
       12)sdiff    键名1 键名2             求**差集**:以集合1减去集合2中共有的数据,把剩下的数据给显示出来;
```

```
       13)sdiffstore  新的键名 键名1 键名2  求**差集**并保存在新的键
```

```
       14)srandmember 键名                随机返回集合键中的一个值
```

#### <font color = '#ff0000'>4.哈希集合:hash::存储的是【键值对】数据:Key-Value集合</font>       :video_game:

```
        1)hset     键名 字段名1 值1        生成hash集合的键并接受字段值
```

```
        2)hmset    键名 字段名1 值1 字段名2 值2   一次性插入多组键值对数据(字段值)
```

```
        3)hget     键名 字段名             获取该键中对应字段的值
```

```
        4)hmget    键名 字段1 字段2 字段3   获取多个字段的值
```

```
        5)hgetall  键名                   获取该键中所有的键值对数据
```

```
        6)hincrby  键名 字段名 数值         将键中对应的值进行增加数值的操作
```

```
        7)hexists  键名 字段名             判断该字段是否在集合中存在
```

```
        8)hdel     键名  字段名            删除集合中的字段
```

```
        9)hlen     键名                   统计该键中的键值对总个数
```

```
       10)hkeys    键名                   获取该键中所有的字段名
```

```
       11)hvals    键名                   获取该键中所有的值
```

#### <font color = '#ff0000'>5.有序集合: zset: 用来存储字符串类型的数据的集合，通过每一个值关联一个分数，然后利用分数达到排序的效果(从小到大)</font>   :yellow_heart:   :yum:    :yen:

```
        1)zadd     键名 分数1 值1 分数2 值2 生成有序集合以及对应的数据
```

```
        2)zrange   键名 开始下标 结束下表    查看集合中的数据
```

```
        3)zcard    键名                   统计集合中的总个数
```

```
        4)zcount   键名 最低分 最高分       根据分数区间统计值的总个数
```

```
        5)zincrby  键名 增加的分数 值       对该值的分数进行增加
```

```
        6)zrank    键名 值                返回该值对应的位置下标(把最小的值看成是第一个下标元素)
```

```
        7)zrevrank 键名 值                返回该值对应的位置下标(把最大的值看成是第一个下标元素)
```

```
        8)zscore   键名 值                查看该值对应的分数
```

```
        9)zrevrange 键名 开始下标 结束下标   降序查看
```

```
       10)zscan    键名 游标0             查看键中的值和对应的分数
```

```
       11)zrem     键名 值1 值2           删除键中的值
```

```
       12)zreamrangebyscore 键名 最低分 最高分   删除分数区间内的值
```

### 六、Redis数据库的事务操作     :camping:

1.事务:指的是一次可以执行多个操作命令-->把对应的操作命令放在事务中，一旦执行事务，就会把事务中所有的操作命令全部执行.           :earth_africa:

   对比:在之前的操作中，每次执行操作命令时，都是一个一个按顺序执行的，有了事务，可以同步执行操作.      :dizzy:     :detective: 

2.

### 七、Redis数据库的备份与恢复

#### <font color = '#00ff00'>1.备份: Save</font>   :back: 

备份完成后，会在redis的安装目录中生成一个**dump.rdb**文件,数据库的备份文件；

#### 2.**Redis**的备份路径      :leftwards_arrow_with_hook:  

有时候备份完成后，找不到该文件或不清楚**Redis**的安装目录，就可以借助命令: **config get dir**,显示**Redis**的路径;

#### <font color = '#ff0000'>3.恢复 </font>     :hammer_and_wrench:     

只需要把备份好的dump.rdb文件，放入到redis安装目录中，重启redis数据库即可；

------

:rabbit2::rabbit2::rabbit::racehorse::rabbit2::rabbit::rabbit::game_die::deer:

### 一、redis数据库的配置与连接：    :laughing:

1.解压redis数据库的软件包/工具包

2.启动redis数据库服务:dos命令行打开

```
        redis-server.exe  redis.windows.conf
```

3.连接redis数据库

```
        再重新进入DOS系统窗口,再次进入redis目录;
     
        redis-cli.exe
```

4.验证

```
        输入ping命令，得到PONG的结果值，就代表环境OK
```

redis-cli.exe

:hash:

:yellow_heart:

:relieved:

:baby:
